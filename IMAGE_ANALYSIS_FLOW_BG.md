# Поток на изображенията и AI анализа

Документът описва детайлните стъпки от качване на изображенията до визуализиране на анализа във фронтенда, включително ключови зависимости и потенциални точки на проблеми.

## 1) Качване и обработка на изображенията (ImageUploadScreen)
- **Инициализация и логове**: при mount се стартира сесия за uploadDiagnostics и се логва средата (localhost/preview/production). Това подсказва, че аналитичният поток разчита на клиентските логове за диагностика на проблеми при качване.【F:src/components/screens/ImageUploadScreen.tsx†L39-L69】
- **Избор на файл и валидация**: за всяко око се приема само `image/*`, ограничено до 10MB. Невалидният тип или размер връщат грешка и не започват обработка.【F:src/components/screens/ImageUploadScreen.tsx†L136-L175】
- **Четене и конвертиране**: файлът се чете като Data URL; ако резултатът не е string или не започва с `data:image/`, процесът спира с грешка. Тук се удостоверява, че входът е подходящ за canvas обработка и последващи AI стъпки.【F:src/components/screens/ImageUploadScreen.tsx†L201-L225】
- **Компресия (двуфазна)**: първа компресия при 0.92 качество и макс ширина 800px, следвана от втора (0.88) при изображения >1MB. Ако крайният размер надхвърля 2MB, качването се отказва. Тази зависимост гарантира лимитиран размер за по-стабилен трансфер към AI API.【F:src/components/screens/ImageUploadScreen.tsx†L227-L286】
- **Отваряне на crop редактора**: при успешна компресия се активира IrisCropEditor и временно изображението се пази за редакция. Ако компонентът бъде размонтиран, процесът се прекъсва, което е важна защита срещу състезателни условия.【F:src/components/screens/ImageUploadScreen.tsx†L287-L300】
- **Запис след crop**: при запазване се валидира `data:image/` формата, прави се нова двуфазна компресия, проверява се лимитът 2MB и чак тогава изображението се записва в `leftImageRef`/`rightImageRef`, като се обновява UI чрез `imagesVersion`. Тези стъпки предотвратяват подаване на прекалено големи или невалидни данни към следващите екрани.【F:src/components/screens/ImageUploadScreen.tsx†L401-L520】

## 2) Централно потвърждение и преход към анализ (App)
- **Валидиране на входа**: `handleImagesComplete` проверява наличието на обекти и `dataUrl` полета за двете очи и блокира дублиращи извиквания чрез `screenTransitionLockRef`. Това е ключов предпазител срещу състезателни условия и липсващи данни.【F:src/App.tsx†L116-L200】
- **Контрол на размер и storage**: допълнителни проверки ограничават всяко изображение до ~200KB и измерват localStorage/kv usage; при висока заетост процесът се спира. Това е зависимост, която може да намали точността ако агресивната компресия в предишната стъпка намали детайла.【F:src/App.tsx†L220-L270】
- **Запазване и преход**: валидираните изображения се пазят в рефове, задава се `imagesReady=true`, прави се кратко изчакване за „memory stabilization“ и се преминава към екрана за анализ. Тази фаза е точката, в която се предава оригиналният `dataUrl` към AI анализатора.【F:src/App.tsx†L271-L314】

## 3) Стартиране на AI анализа (AnalysisScreen)
- **Зареждане на конфигурацията**: при mount се проверяват входните изображения, зарежда се AI конфигурацията с приоритет към `window.spark.kv` (`ai-model-config`) и fallback към `useKVWithFallback` hook. Липсата на API ключ прекъсва анализа – критична външна зависимост.【F:src/components/screens/AnalysisScreen.tsx†L429-L520】
- **Стартиране на процеса**: след успешно зареждане на конфигурацията се стартира `performAnalysis`, като се маркира състоянието `analysisRunning` за предотвратяване на дублиращи изпълнения.【F:src/components/screens/AnalysisScreen.tsx†L521-L546】
- **Параметризация и последователност**: `performAnalysis` извлича provider/model/API ключ, настройва забавяне между заявките (`requestDelay`) и брой стъпки (`requestCount`). Анализът изпълнява поредица от заявки (ляв ирис → десен → хранителен план → добавки → психо препоръки → специални препоръки → изследвания → детайлен анализ → резюмета), с прогрес и пауза между всяка за избягване на rate limits.【F:src/components/screens/AnalysisScreen.tsx†L546-L744】
- **Изход към фронтенда**: генерираният `AnalysisReport` включва оригиналните `dataUrl` изображения и се връща към App чрез `onComplete`, което задейства показването на екрана Report. Това е точката, където фронтендът визуализира резултатите и ги пази в историята (в лека версия без изображения).【F:src/components/screens/AnalysisScreen.tsx†L718-L749】【F:src/App.tsx†L335-L360】

## 4) Ключови зависимости и потенциални проблеми
- **API ключ и provider**: цялата AI верига разчита на валиден ключ в `ai-model-config` (OpenAI или Gemini). Липсващ или некоректен ключ спира анализа преди да започне.【F:src/components/screens/AnalysisScreen.tsx†L429-L520】
- **Клиентска компресия**: двуфазната компресия до 2MB, последвана от допълнителна 200KB граница в App, може да премахне детайли от ириса и да понижи прецизността спрямо LLM интерфейс, който приема оригинали. Това е основна хипотеза за по-слаби находки.
- **Забавяне между заявките**: `requestDelay` по подразбиране 60s между всяка AI стъпка (8 стъпки) забавя анализа и увеличава риска от таймаути/прекъсвания; оптимизацията на тези стойности или batch заявки би подобрила надеждността.【F:src/components/screens/AnalysisScreen.tsx†L568-L637】
- **LocalStorage/kv натоварване**: проверките за заетост на storage могат да блокират потребители с голяма история; необходимо е авто-чистене или по-леки изображения, за да се избегнат фалшиви откази.【F:src/App.tsx†L258-L270】

## 4.1) Защо може да липсват проблемни зони (хипотези и доказуеми стъпки)
- **Детайлите се губят преди да стигнат до модела**: едновременното ограничение 2MB при качване и допълнителният 200KB лимит в App компресират агресивно ирисите и премахват фини пигментни петна/лакуни. В обикновен LLM интерфейс се подават сурови изображения без тази загуба, което обяснява по-добрите находки там.【F:src/components/screens/ImageUploadScreen.tsx†L227-L300】【F:src/App.tsx†L220-L314】
- **Моделът вижда находки, но ги „пречиства“ заради логиката за статуси**: prompt-ът изисква status "normal" когато няма симптом или сигурна находка, а препоръките се генерират само от зони със статус различен от normal. Така съмнителни структури се филтрират още в JSON-а и не стигат до финалния екран.【F:src/components/screens/AnalysisScreen.tsx†L890-L1020】【F:src/components/screens/AnalysisScreen.tsx†L1089-L1150】
- **Диагностичният отговор остава скрит**: AI може да описва видими артефакти в диагностичния свободен текст, но стойността се пази само в `diagnosticResponses` и UI по подразбиране не го показва. Ако парсването на JSON е консервативно, реалните находки може да стоят в диагностичния лог, а не в изведените зони.【F:src/components/screens/AnalysisScreen.tsx†L816-L928】
- **Строгото JSON парсиране може да отреже съдържание**: `robustJSONParse` чисти блокове, нови редове и опитва поправки. Ако моделът върне смесен текст+JSON, парсирането може да изхвърли описателната част и да остави празни масиви за артефакти. Проверявайте логовете за предупреждения „Не може да се извлече валиден JSON“ при случаи с празни находки.【F:src/components/screens/AnalysisScreen.tsx†L254-L420】
- **Пример за контролна проверка**: при активиран diagnostics (по подразбиране true) качете по-голямо, минимално компресирано изображение (например 400–600KB), прегледайте `diagnosticResponses` в конзолата и сравнете със зоните в JSON. Ако текстът описва артефакти, но масивите са празни, проблемът е във филтрирането/парсирането, не във виждането.

## 4.2) Потенциални проблеми в логиката между prompt, база знания и LLM
- **Базата знания не се инжектира в prompt-а**: `knowledgeContext` събира карта на ириса, артефакти и препоръки, но стойността се логва без да се добавя в prompt-а. Моделът получава само текстовите инструкции, без подсилена карта на зони и артефакти, което може да води до по-слаби попадения спрямо интерфейс, който подава ясен контекст.【F:src/components/screens/AnalysisScreen.tsx†L879-L895】
- **Смесени инструкции „не пропускай“ vs. „не измисляй“**: в основния prompt има едновременно настояване да се включат и малки/съмнителни находки и изрична забрана за „виртуални“ находки. При изображения с ниско качество това двусмислие може да наклони модела към консервативно маркиране `status:"normal"` и да скрие находки.【F:src/components/screens/AnalysisScreen.tsx†L896-L931】
- **Логиката за статуси зависи от симптоми**: правилата 1–4 комбинират видима находка и симптоматика при присвояване на `status`. Ако в анкетата липсват симптоми, една и съща визуална находка може да се свали до `attention` или дори `normal`, което по-късно не попада в препоръките. Необходимо е отделно правило „видима находка → минимум attention“, независимо от симптомите.【F:src/components/screens/AnalysisScreen.tsx†L927-L931】【F:src/components/screens/AnalysisScreen.tsx†L1089-L1150】
- **Кратък експеримент за потвърждение**: логнете финалния prompt преди изпращане и проверете дали съдържа карта на зоните и артефактите; ако липсва, добавете временно `${knowledgeContext}` и сравнете брой намерени `artifacts`/`zones` в JSON. Втори тест: задайте тестови анкети без симптоми и със симптоми, но с едно и също изображение, и сравнете броя non-`normal` зони, за да се види ефекта от правилата 1–4.

## 4.3) Бързи поправки за липсващи находки (фокус: само фронтенд)
- **Възстановяване на детайла**: временно увеличете лимита в App (`MAX_STORAGE_IMAGE_SIZE`) до 400KB и изключете втория компрес при crop. Очакван ефект: повече „attention/concern“ зони при един и същ тестов ирис.
- **Уеднаквен prompt**: добавете `${knowledgeContext}` в генератора на prompt и премахнете двусмислени фрази като „не добавяй виртуални находки“; оставете ясно „опиши всички видими структури“. Очакван ефект: повече артикулирани артефакти в JSON.
- **Независим статус по визуален сигнал**: ако `artifacts.length > 0`, насилете статус минимум `attention` преди да се приложат симптомите. Очакван ефект: същият брой non-`normal` зони при анкета със/без симптоми.
- **Показване на диагностичния текст**: добавете секция „Диагностичен лог“ под отчетите, видима по подразбиране, за да не се губят описани, но непарсирани находки.

## 5) Препоръки за подобрение (без бекенд)
- **По-гъвкави лимити (пример)**: разрешете до 600KB след crop и намалете изискването в App от ~200KB на 400KB, за да се запази повече детайл. Тест: качете 2 версии (200KB и 400–600KB) и сравнете броя non-`normal` зони.
- **Инжектиране на знания в prompt-а**: включете `${knowledgeContext}` директно в основния prompt преди JSON инструкциите. Тест: логнете финалния prompt и сравнете броя `artifacts` преди/след добавянето.
- **Ясна политика за статусите**: добавете правило „видима находка → минимум `attention`“, независимо от симптомите. Тест: един и същ ирис със/без симптоми трябва да дава еднакъв статус, ако има видима структура.
- **Показване на скрития диагностичен текст**: визуализирайте `diagnosticResponses` под JSON резултатите или добавете бутон „Показване на диагностиката“. Пример: ако JSON зоните са празни, но текстът описва „пигментна лакуна“, тя става видима за потребителя.
- **По-кратки паузи между заявките**: намалете `requestDelay` от 60s до 15–20s и обединете допълнителните препоръки (добавки + психо) в една заявка. Тест: измерете времето „анализ стартира → готов отчет“ и броя таймаути.
- **Автоматична проверка на качество**: на клиентска страна проверявайте резолюция/острина преди компресия; ако `width < 600px` или картината е размазана (Laplacian blur threshold), покажете предупреждение и примерен ре-ъплоуд.
